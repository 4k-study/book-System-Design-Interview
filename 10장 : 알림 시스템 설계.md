# 10장 알림 시스템 설계

알림 시스템은 모바일 푸시 알림, SMS, 이메일 세가지로 분류할 수 있다.

# 1단계 문제 이해 및 설계 범위 확정

알림 시스템은 정해진 정답이 없고, 문제 자체가 모호하기 때문에 적절한 질문을 통해 요구사항을 스스로 알아내야 한다.

질문 예시

- 알림 종류 (푸시, SMS, 이메일 등)
- 실시간 여부 (soft real-time, real-time 등)
- 지원 단말 (ios, aos, pc 등)
- 알람 발행자 (클라이언트 애플리케이션, 서버 배치 등)
- 사용자 알람 거부 여부
- 하루 발생 알람 개수

# 2단계 개략적 설계안 제시 및 동의 구하기

iOS, AOS, SMS, Email에 대해 다음과 같은 내용을 알아보자

- 알림 유형별 지원 방안
- 연락처 정보 수집 절차
- 알림 전송 및 수신 절차

### 알림 유형별 지원 방안

알림 매커니즘

**iOS 푸시 (현재는 firebase가 해준다)**

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/5eb7889e-1316-4b8c-8aed-25aa6b932388)

- 알림 제공자 : 알림 요청을 만들어 애플 푸시 알림 서비스(APNS)로 보낸다.
    - 단말 토큰 : 알림 요청을 보내는데 필요한 고유 식별자
    - 페이로드 : 알림 내용을 담을 JSON 딕셔너리
        
        ```bash
        {
        	"aps" : {
        				"alert": {
        						"title":asdf
        						"body":asdf
        						"action-loc-key":asdf
        					},
        					"badge":
        			}
        }
        ```
        
- APNS : 애플이 제공하는 원격 푸시 서비스

**SMS**

보통 Twilio, Nexmo와 같은 서드파티 서비스를 사용한다.

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/6e352e29-e3c1-4d91-a757-b4310838651d)

**Email**

이베일 송신 서버를 만들어도 좋지만, 대부분 서드파티 서비스를 사용한다. (Sendgrid, Mailchimp)

도식은 위와 같다.

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/fba8cf33-7a65-407d-9642-02937934cb80)

위의 알림 유형을 한 시스템으로 묶으면 이렇게 된다.

### 연락처 정보 수집 절차

알림을 보내기 위해 모바일 단말 토큰, 전화번호, 이메일 등의 정보가 필요하다.

이는 사용자가 앱을 설치하거나, 계정을 등록할 때 정보를 수집하여 데이터베이스에 저장한다.

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/8c2b4d7b-6a0b-47e2-a30c-6d5441d04322)

보통은 위와 같이 파생 테이블에 관련 정보를 담는 것 같다. device는 여러개일 수 있으니 1:N 관계이다.

### 알림 전송 및 수신 절차

**개략적 설계안**

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/82128db7-efe2-4174-a622-cc83c5e105d5)

- 서비스 : MSA, 분산환경, cronjob등 다양한 서비르를 뜻한다.
- 알림 시스템 : 알림 전송/수신 처리의 핵심으로서 알림 전송을 위한 API, 서드파티 서비스에 전달할 페이로드를 만들어야 한다.
- 서드파티 서비스 : 알림 시스템에게 받은 데이터로 사용자에게 실제 알림을 전송한다. 서비스 추가/제거와 같은 확장성을 고려해야 한다.

설계 문제

- SPOF : 알림 시스템이 한개뿐이다.
- 규모 확장성 : 알림 시스템이 한 개 뿐이여서 DB, 캐시 등 컴포넌트 규모를 늘릴 방법이 없다.
- 성능 병목 : 시스템 과부하가 야기된다.

**개선된 설계안**

개선 목록

- DB와 캐시를 알림 서버로부터 분리 한다.
- 알림 서버를 증설하고, 수평적 규모 확장이 이루어지도록 한다.
- 메시지 큐를 이용해 컴포넌트 사이의 강한 결합을 끊는다.

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/199751b4-f51a-4c52-823a-86160eee2e65)

- 알림 서버
    - 알림 전송 API : 스팸 방지를 위해 사내 서비스 또는 인증된 클라이언트만 사용 가능
    - 알림 검증 : 이메일 주소, 전화번호 검증
    - DB 또는 캐시 : 알림에 포함시킬 데이터를 가져오는 기능
    - 알림 전송 : 알림 데이터를 메시지 큐에 넣어 병렬처리한다.
- 캐시 : 사용자 정보, 단말 정보, 알림 템플릿 등
- DB : 사용자, 알림, 설정등 다양한 정보를 저장한다.
- 메시지 큐 : 시스템 컴포넌트 간 의존성을 제거하기 위해 사용 (버퍼, 단말간 SPOF 방지)
- 작업 서버 : 메시지 큐에서 꺼내서 각 서비스로 전달한다.

# 3단계 상세 설계

### 안정성

**데이터 손실 방지**

알림이 지연되거나 순서가 달라져도 되지만, 사라지면 곤란하다.

알림 데이터는 DB에 저장하고, 재시도 매커니즘을 구현해야 한다. (알림 로그도 한 가지 방법이다.)

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/797cf202-6e29-484e-95da-49d32d1a110e)

**알림 중복 전송 방지**

분산 시스템의 특성상 같은 알림이 여러 번 반복되는 것은 완전히 막을 수 없다. 

그 빈도를 줄이는게 중요한데, 이벤트 ID를 검사하는 방법도 있다.

### 추가로 필요한 컴포넌트 및 고려사항

추가 컴포넌트 예시

- 알림 템플릿
- 알림 설정
- 이벤트 추적
- 시스템 모니터링
- 처리율 제한
- 기타 등등

**알림 템플릿**

알림은 하루에도 수백만 건 이상 처리하지만, 대부분의 형식은 비슷하다.

이 유사성을 이용하여 알림 템플릿을 만들어두면, 형식을 일관성있게 유지할 수 있다.

**알림 설정**

알림 설정을 조회하여 알림 전송 전에 체크한다.

- 받고 싶은 채널
- 받고 싶은 시간대
- 기타 등등

**전송률 제한**

한 사용자가 받을 수 있는 알림의 빈도를 제한하는 것이다.

알림이 너무 잦다면, 알림을 끌 수 있기 때문이다.

**재시도 방법**

서드파티 서비스에서 알림 전송을 실패하면 알림 재시도 큐에 넣는다. 실패가 반복되면 alert를 보낸다.

**푸시 알림과 보안**

iOS, AOS는 appKey, appSecret으로 보안을 유지한다.

**큐 모니터링**

가장 중요한 메트릭은 큐에 쌓인 알림의 개수이다. 큐에 알림이 많이 쌓이면 서버를 증설해야 한다.

**이벤트 추적**

알림 확인율, 클릭율등 실제 앱 사용으로 이뤄지는 비율은 사용자를 분석하는데 중요하다.

보통 데이터 분석과 이벤트 추적기능은 알림 시스템과 통합한다.

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/ac7072c8-e9fc-4564-8806-f040d99812ad)

### 수정된 설계안

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/73481f6d-b3b7-4495-8156-a46c169e3afa)

수정된 컴포넌트

- 알림 서버 인증 및 전송률 제한
- 전송 실패 재시도
- 전송 템플릿
- 모니터링 및 추적 시스템

# 4단계 마무리

해당 설계에서 시스템 컴포넌트 사이의 결합도를 낮추기 위해 메시지 큐를 적극적으로 사용했다.

각 컴포넌트의 구현 방법 및 최적화 기법에 대해서도 심도있게 알아보았다. 또한 다음을 강조했다.

- 안정성
- 보안
- 이벤트 추적 및 모니터링
- 사용자 설정
- 전송률 제한
