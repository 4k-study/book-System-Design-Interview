# 13장 검색어 자동완성 시스템

# 1단계 문제 이해 및 설계 범위 확정

질의 예시

- 사용자가 입력하는 단어는 자동완성될 검색어의 첫 부분이어야 하는지, 중간이어도 되는지
- 몇개의 자동완성 검색어가 표시되어야 하는지
- 맞춤법 검사 기능 제공 유무
- 질의 언어
- 대문자나 특수 문자 처리
- DAU

### 요구사항

- 빠른 응답 속도 : 검색어를 입력함에 따라 자동완성 검색어도 충분히 빨리 표시되어야 한다. (100ms)
- 연관성 : 자동완성되어 출력되는 검색어는 사용자가 입력한 단어와 연관된 것이어야 한다.
- 정렬 : 시스템의 계산 결과는 인기도등의 순위 모델에 의해 결정되어야 한다.
- 규모 확장성 : 트래픽 감당을 위한 확장 가능성을 가져야 한다.
- 고가용성 : 시스템에 문제가 생겨도 시스템은 계속 사용 가능해야 한다.

### 개략적 규모 추정

- DAU - 1000만명으로 가정
- 한 사용자당 매일 10건의 검색 수행한다 가정
- 질의의 크기는 평균적으로 20바이트로 가정
    - 문자 인코딩은 ASCII로 가정
    - 질의문은 평균적으로 4개 단어로 가정, 각 단어는 평균 5글자로 구성
- 검색창에 글자를 입력할 때마다 백엔드에 요청을 보낸다. 따라서, 평균적으로 1회 검색당 20건의 요청이 백엔드로 전달됨.
- 대략 초당 24000건의 QPS 발생
- 최대 QPS = 48000
- 질의 가운데 20% 정도는 신규 검색어.

# 2단계 개략적 설계안 제시 및 동의 구하기

시스템은 두 부분으로 나뉜다.

- 데이터 수집 서비스 : 사용자가 입력한 질의를 실시간으로 수집하는 시스템. 데이터가 많은 경우 그다지 바람직하지 않지만 설계안을 만드는 출발점으로 괜찮다.
- 질의 서비스 : 주어진 질의에 다섯 개의 인기 검색어를 정렬하는 시스템

### 데이터 수집 서비스

질의와 사용자 빈도를 저장하는 빈도 테이블이 있다고 가정하자.

twitch, twitter, twitter, twillo를 순서대로 검색하면 상태가 다음과 같이 바뀌어 나가게 된다.

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/4bc30fc7-0e3f-49e9-97c5-386f788bf078)

### 질의 서비스

빈도 테이블에 query - frequency 쌍으로 저장한다.

# 3단계 상세 설계

다음 컴포넌트를 상세 설계하고, 최적화 해보자

- trie 자료 구조
- 데이터 수집 서비스
- 질의 서비스
- 규모 확장이 가능한 저장소
- trie 연산

### 트라이 자료구조

설계안에선 rdbms를 사용했다. 이는 효율적이지 않다. → 트라이를 사용하자

트라이는 문자열들을 간략하게 저장할 수 있는 자료구조다. trie는 문자열을 꺼내는 연산에 초점을 맞추어 설계된 자료구조이다.

- 트라이는 트리 형태의 자료구조다.
- 이 트리의 루트 노드는 빈 문자열을 나타낸다.
- 각 노드는 글자(char) 하나를 저장하며, 26개의 자식 노드를 가질 수 있다.
- 각 트리 노드는 하나의 단어, 또는 접두어 문자열을 나타낸다.

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/96cfa3df-a5f9-41e8-8e82-3b7031b49ce5)

다음은 tree, try, true, wish, win이 보관된 트라이다.

기존의 query - frequency형태의 자료구조보다 더 효율적이고, 빈도를 저장할 필요도 없다.

용어 정리

- p : 접두어 길이
- n : 트라이 안에 있는 노두 개수
- c : 주어진 노드의 자식 노드 개수

가장 많이 사용된 질의어 k 개 산출

- 해당 접두어 표현 노드 검색  / O(p)
- 해당 노드부터 하위 트리 탐색하여 모든 유효 노드를 검색한다. (유효한 검색 문자열을 구성) / O(c)
- 유효 노드들을 정렬하여 가장 인기있는 검색어 k개를 찾는다. / O(clogc)

이 알고리즘은 최악의 경우에는 전체 트라이를 다 검색해야 하는 일이 생길 수 있습니다. 따라서 접두어의 길이 제한 하거나, 각 노드에 인기 검색어를 캐시한다.

**접두어 최대 길이 제한**

긴 검색어를 입력할 일이 거의 없기 때문에 p값은 작은 정수값이어도 안전하다. (50정도?)

이렇게 되면 시간 복잡도는 상수로 바뀌게 된다.

**노드에 인기 검색어 캐시**

각 노드에 N개의 인기 검색어를 캐시해두면 시간 복잡도가 낮아진다. 이는 저장 공간이 부족해진다는 단점이 있다.

캐시 히트를 하게 되면 시간 복잡도는 O(1)로 바뀐다.

### 데이터 수집 서비스

검색창에 타이핑을 할 때마다 실시간으로 데이터를 수정하는 방식은 실용적이지 않다.

- 질의마다 트라이를 갱신하면 서비스는 느려질 것이다.
- 일단 트라이가 만들어지고 나면 인기 검색어는 그다지 자주 바뀌지 않을 것이다.

구글같은 검색 애플리케이션은 데이터가 엄청 신선할 필요가 없다.

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/f76ed01f-b982-4d68-8685-32bfc6771a55)

**데이터 분석 서비스 로그**

질의에 관한 원본 데이터가 보관되고, 데이터가 추가될 뿐 수정은 이루어지지 않는다.

또한 인덱스도 걸지 않는다.

**로그 취합 서버**

나오는 로그 양이 엄청나고 데이터 형식도 제각각이다.

데이터 취합 방식은 서비스에 따라 달라진다.

- 실시간(트위터) : 신선도가 중요해 데이터 취합 주기를 짧게 가져간다.
- 비실시간 : 일주일에 한 번 정도로 로그를 취합해도 충분할 것이다.

**취합된 데이터**

데이터는 query, time, frequency로 저장된다.

**작업 서버**

비동기 작업을 실행하는 서버 집합이다.

트라이 자료구조를 만들고 DB에 저장하는 역할을 담당한다.

**트라이 캐시**

트라이 캐시는 분산 캐시 시스템으로 트라이 데이터를 캐시하여 읽기 성능을 높인다.

매주 트라이 DB의 스냅샷을 떠서 갱신한다.

**트라이 DB**

트라이를 저장하는 DB는 두 가지 선택지가 있다.

1. document : 새 트라이를 매주 만들 것으로, 주기적으로 트라이를 직렬화하여 DB에 저장할 수 있다. (Mongo)
2. key-value : 해시 테이블로 변환한다.
    1. 트라이에 보관된 모든 접두어를 해시 테이블 키로 변환
    2. 각 트라이 노드에 보관된 모든 데이터를 해시 테이블 값으로 변환
    
    ![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/30496f57-65bd-4fee-b128-ea4cc0a16a91)

    

### 질의 서비스

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/6324c0f7-82fc-4b78-84b3-0e2c124d7073)

1. 요청을 보내면 로드밸런서로 간다.
2. 로드밸런서가 적절하게 API 서버로 요청을 분배한다.
3. API 서버는 트라이 캐시에서 데이터를 가져와 검색어 제안 응답을 구성한다.
4. 데이터가 트라이 캐시에 없는 경우 트라이 DB에서 처리한다.

질의 서비스는 매우 빨라야 한다. 다음과 같은 최적화 방안이 있다.

- AJAX 요청
- 브라우저 캐싱 : 자동완성 검색어 제안 결과는 자주 바뀌지 않는다. (실제로 구글은 1시간짜리 max-age를 가진 캐시를 사용한다)

### 트라이 연산

검색어 자동 완성의 핵심이다.

**트라이 생성**

작업 서버가 담당하며, 데이터 분석 서비스의 로그나 DB로부터 취합된 데이터를 이용한다.

**트라이 갱신**

두 가지 방법이 있다.

1. 매주 한 번 갱신하여 기존 트라이를 대체한다.
2. 트라이의 각 노드를 개별적으로 갱신한다.
    1. 성능이 좋지 않다.
    2. 트라이가 작을 때 고려하는게 좋다.
    3. 트라이를 갱신할 때 모든 상위 노드도 대체해야해서 비효율적이다.

**검색어 삭제**

혐오성, 폭력성, 문란등 제거해야 할 검색어가 있다.

트라이 앞에 필터 계층을 두어 부적절한 질의어가 반환되지 않도록 한다.

### 저장소 규모 확장

샤딩(prefix 기준)

- 이 방법은 최대 26개로 제한된다. 알파벳이 26개기 때문인다.
- 서버를 26개 이상 만드려면, 계층형 샤딩을 해야한다. (두 번째 prefix)

샤딩(과거 질의 패턴 분석)

- 샤드 관리자가 서버에 저장된 양을 기준으로 샤딩한다.

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/af696cce-2f38-43d6-878d-4f5117f20584)

# 4단계 마무리

추가로 해보면 좋을 질문들

- 다국어 지원 서비스로 확장하기 위한 방법(키워드 유니코드)
- 국가별 인기 검색어 순위 (키워드 CDN)
- 실시간 검색어 추이 반영 (키워드 샤딩, 순위모델, 가중치, 스트리밍 등)
