# 15장 구글 드라이브 설계

# 1단계 문제 이해 및 설계 범위 확정

영상 스트리밍, 댓글, 좋아요, 재생목록 저장, 구독 등

질문 목록

- 가장 중요한 기능
- 지원 클라이언트
- 파일 암호화 여부
- 파일 크기 제한
- 일간 능동 사용자 수

이번 장에서 초점을 둘 기능은 다음과 같다.

- 파일 업로드
- 파일 다운로드
- 파일 갱신 이력 조회
- 파일 공유
- 파일의 변동사항 알림

* 동시 편집은 기능에서 제외한다.

중요한 비 기능적 요구사항

- 안정성
- 빠른 동기화 속도
- 네트워크 대역폭
- 규모 확장성
- 높은 가용성

### 개략적 규모 추정

- DAU : 1000만
- 한 사용자는 10GB의 무료 저장 공간 할당
- 매일 사용자가 하루에 2 파일 업로드
- 파일 평균 크기는 500KB
- 총 저장 용량 500PB
- 업로드 API QPS = 약 240

# 2단계 개략적 설계안 제시 및 동의 구하기

초반 설계

- 파일을 올리고 다운로드 하는 웹 서버
- 사용자 데이터, 로그인 정보, 파일 정보 등의 메타데이터를 보관할 데이터 베이스
- 파일을 저장할 저장소 시스템

### API

1. 파일 업로드 API
    1. 단순 업로드
    2. 이어 올리기
2. 파일 다운로드 API
3. 파일 갱신 히스토리

### 한 대 서버의 제약 극복

파일 시스템이 가득 차게 되면 데이터를 샤딩해서 다른 서버에 나누어 저장한다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4b36e261-a272-46e0-bb72-1d3c2abc0a30/16630037-1069-49c5-8128-1e2e319aa5e7/Untitled.png)

- 로드밸런서 : 트래픽 분산, 장애 서버 우회
- 웹 서버 : 트래픽에 따른 증설 가능
- 메타데이터 DB : DB 파일 저장 및 서버에서 분리
- 파일 저장소 : 다중화를 통해 가용성, 무손실 보장

### 동기화 충돌

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4b36e261-a272-46e0-bb72-1d3c2abc0a30/13bf5fdc-cd4c-4d63-920f-565f1dc768e9/Untitled.png)

이 상태에서 파일은 두 가지 버전이 존재한다. 사용자 2가 가지고 있는 로컬 사본과, 서버에 있는 최신 버전

이는 두 파일을 병합할 지 대체할지 정해야 한다.

### 개략적 설계안

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/4b36e261-a272-46e0-bb72-1d3c2abc0a30/b08e0917-85f2-42d7-97a4-050a11d6d7c0/Untitled.png)

- 블록 저장소 서버 : 파일 블록을 클라우드에 업로드하는 서버이다.
    - 각 파일은 여러개의 블록으로 나눠 저장하며, 고유한 해시값이 할당된다.
    - 이 해시값은 메타데이터 DB에 저장된다.
    - 각 블록은 독립적인 객체로 S3에 저장된다.
    - 파일을 재구성 하려면 각 블록을 순서대로 합쳐야 한다.
- 아카이빙 저장소 : 오랫동안 사용되지 않은 비활성 데이터를 저장한다.
- 메타데이터 DB : 사용자, 파일, 블록, 버전드으이 메타데이터를 저장한다.
- 오프라인 사용자 백업 큐 : 클라이언트가 접속중이 아니어서 파일의 최신 상태를 확인할 수 없을때 해당 정보를 이 큐에 두어 동기화 한다.

# 3단계 상세 설계

### 블록 저장소 서버

파일 업데이트를 최적화 하는 방법

- 델타 동기화 : 파일이 수정되면 수정이 일어난 블록만 동기화
- 압축 : 블록 단위로 압축한다. (gzip, bzip2)

### 높은 일관성 요구사항

이 시스템은 강한 일관성을 가져야 한다. 이는 메타데이터 캐시와 DB에도 적용되어야 한다.

- 메모리 캐시
    - 캐시에 보관된 사본과 DB에 있는 원본이 일치한다.
    - DB에 보관된 원본에 변경이 발생하면 캐시에 있는 사본을 무효화 한다.
- RDBMS : ACID로 인해 일관성 보장
- NoSQL : 동기화 로직을 프로그램 안에 넣어야 한다.

### 업로드 절차

사용자가 파일을 업로드하는 절차에 대해 알아보자.

**파일 메타데이터 추가**

1. 클라이언트에서 요청을 보낸다.
2. 새 파일의 메타데이터를 DB에 저장하고 업로드 상태를 **대기**로 변경
3. 새 파일이 추가되었음을 알림 서비스에 통지
4. 알림 서비스는 관련된 클라이언트에게 알림을 보냄

**파일을 클라우드 저장소에 업로드**

1. 클라이언트가 파일 블록 저장소 서버에 업로드
2. 블록 저장소는 파일을 블록으로 쪼개고, 압축하고, 암호화 하여 클라우드에 전송
3. 클라우드에서 업로드가 끝나면 콜백 API를 호출함
4. 메타데이터 DB에 기록된 파일의 상태를 **완료**로 변경
5. 알림 서비스에 파일 업로드를 통지

### 다운로드 절차

파일 다운로드는 파일이 새로 추가되거나, 편집되면 자동으로 시작된다. 어떻게 감지하는 걸까?

- 접속중인 경우 파일 변경에 의한 알림 서비스가 알려준다.
- 접속중이지 않은 경우 데이터 캐시에 보관되어 접속중일 때 새 버전을 가져간다.

**다운로드 절차**

1. 알림 서비스가 파일 변경을 알림
2. 알림 확인 후 메타데이터 요청
3. API 서버는 DB로부터 새 메타데이터 요청
4. 클라이언트는 새 메타데이터를 받는 즉시 블록 다운로드 요청
5. 블록 저장소는 서버는 클라우드 저장소에서 블록 다운로드
6. 클라이언트는 블록을 사용하여 파일 재구성

### 알림 서비스

파일 일관성을 유지하기 위해, 클라이언트는 로컬에서 파일 수정을 감지하는 순간 다른 클라이언트에 그 사실을 알려준다. 이는 충돌 방지를 위해 중요하다.

- 롱 폴링 (드롭박스)
    - 단방향 통신만 필요함
    - 알림을 보낼 일이 많지 않음
- 웹소켓

### 저장소 공간 절약

안정성을 위해 여러 데이터 센터에 보관하는데, 이는 저장용량이 빨리 소진된다.

- 중복 제거 : 중복된 파일 블록을 계정 차원에서 제거한다.
- 지능적 백업 전략을 도입한다.
    - 한도 설정 : 한도가 차면 오래된 순으로 제거
    - 중요한 버전만 보관 : 모든 업데이트 버전을 저장하지 않고, 필요한 버전만 저장한다.
    - 아카이빙 저장소 : 자주 쓰이지 않는 데이터는 아카이빙 저장소로 보낸다.

### 장애 처리

- 로드 밸런서 장애 : 세컨더리 로드밸런서가 활성화 되어야 한다. (heartbeat로 감지)
- 블록 저장소 서버 장애 : 다른 서버가 미완료/대기 상태 작업을 이어 받는다.
- S3 장애 : 지역 다중화를 통해 다른 지역에서 파일을 가져온다.
- API 서버 장애 : API 서버는 무상태성이기 때문에 장애 서버를 격리한다.
- 메타데이터 캐시 장애 : 다중화를 통해 다른 노드에서 데이터를 가져온다.
- 메타데이터 DB 장애 : master 장애시 변경, slave 장애시 다른 slave로 변경
- 알림 서비스 장애 : 롱 폴링은 클라이언트와 연결하고 있어야 해서 복구가 오래걸린다.
- 오프라인 사용자 백업 큐 장애 : 큐 다중화를 통해 구독 관계 재설정

# 4단계 마무리

이번 장은 크게 파일 동기화와, 메타데이터 관리로 나뉜다.

추가로 논의하면 좋은 것들

- 블록 저장소를 거치지 않고 S3에 직접 저장하는 방법? 장단점?
    - 분할, 압축, 암호화 로직을 클라이언트에서 구현해야 한다.
    - 클라이언트가 해킹될 수 있다.
- 접속상태 관리 로직 컴포넌트를 만들어도 좋다.
