![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/f8c22889-18a6-48be-a7a8-20ab7e13dd91)# 1장 사용자 수에 따른 규모 확장성

# 단일 서버

천 리 길도 한 걸음부터. 단일 서버 부터 설계해 보자.

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/ea067382-4d6d-4e9f-b618-74724c7bc4b0)

1. DNS 서버로부터 도메인을 IP로 변환한다. DNS는 보통 third party 가 제공한다.
2. IP 주소가 반환된다.
3. 해당 주소로 HTTP 요청을 보낸다.
4. 웹 서버가 요청에 대한 응답을 한다. (HTML, JSON 등)

# 데이터베이스

사용자가 늘어나면 서버 하나로 감당이 안된다. 트래픽 처리용 웹 서버와, 데이터베이스용 서버로 나눈다.

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/3d133bfa-8de3-4b65-9a12-797f870163f7)

### 데이터 베이스 종류

관계형과 비 관계형으로 나뉜다.

- 관계형 : RDBMS로 불리며 자료를 테이블과 열, 컬럼으로 표현한다.
- 비 관계형 : NoSQL이라고 불리며 Key-Value, Graph, Column, Document 방식으로 한 번 더 나뉜다.

대부분의 상황은 RDBMS를 사용하지만, 다음과 같이 특별한 상황에서 NoSQL을 선택한다.

- 아주 낮은 응답 지연시간
- 다루는 데이터가 비정형인 경우
- 데이터를 직렬화, 역직렬화 할 수 있기만 하면 될 때
- 아주 많은 양의 데이터를 저장할 때

# 수직적 규모 확장 vs 수평적 규모 확장

### 수직적 규모 확장

Scale Up이라고 불리며, 고사양 자원을 추가하는 행위이다.

**특징**

- 서버로 유입되는 트래픽의 양이 적을 때 좋다.
- 매우 단순히 할 수 있다.
- 스케일 업의 한계는 분명하다. (자원은 무한대가 아님)
- 장애에 대한 자동복구(failover)나 다중화(redundancy) 방안이 없다.

### 수평적 규모 확장

Scale Out이라고 불리며, 더 많은 서버를 추가하여 성능을 개선하는 행위를 말한다.

### **로드밸런서**

부하 분산 집합에 속한 웹 서버들에게 트래픽 부하를 고르게 분산한다.

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/ad63edec-71fd-4c4e-831c-a150ecd30476)

1. 사용자는 로드밸런서의 PublicIP로 접근한다.
2. 로드밸런서는 privateIP를 통해 각 서버에게 트래픽을 분산한다.

### 데이터베이스 다중화

흔히 master-slave 방식을 사용하는데, master에 원본을 slave에 복사본을 저장하는 방식이다.

쓰기 연산은 master에서만 이뤄지며, slave에 복사본을 전달한다.

읽기 연산은 slave에서만 이뤄진다. 보통은 읽기 연산이 더 많아 slave가 더 많다.

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/3ed02534-9115-49a6-8515-62c9d3229a92)

**특징**

- 성능 : 병렬로 처리 가능한 쿼리 수가 늘어나서 성능이 더 좋아진다.
- 안정성 : 자연 재해 등으로 서버가 파괴되어도 데이터는 보존된다.
- 가용성 : 데이터를 여러 지역에 복제해 두어서, 장애가 발생해도 다른 서버의 데이터를 가져와 처리한다.

**복구 방법**

- 주 데이터베이스 서버가 죽으면, 부 데이터베이스 서버중 하나가 승격하여 주 데이터베이스 서버가 된다. 단, 승격 당시의 데이터가 최신본이 아닐 수 있어서, 복구 스크립트를 돌려야 한다.
- 부 데이터베이스 서버가 죽으면, 다른 부 데이터베이스 서버들이 트래픽을 감당한다.

로드밸런서와 서버, 데이터베이스 다중화를 하면 다음과 같은 설계안이 나온다.

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/69616c11-24b7-473e-974f-ca2ec4cc1aff)

# 캐시

값비싼 데이터나, 참조되는 데이터를 메모리에 두고 요청이 빨리 처리되도록 하는 저장소이다.

### 캐시 계층

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/1a8ecb3c-8417-455a-86d5-bd8a2691a7b1)

캐시 계층은 데이터베이스보다 훨씬 빠르다. 이는 성능 개선 및 부하를 줄일 수 있다.

읽기 주도형 캐시 전략 : 저장된 데이터가 없으면 DB로부터 가져와 캐시에 저장한다.

### 캐시 사용 시 유의할 점

- 언제 사용할까? → 갱신에 비해 참조가 빈번히 일어나는 경우에 사용해야 한다.
- 어떤걸 캐싱해야 할까? → 휘발성 때문에 중요하지 않은 데이터를 캐싱해야 한다.
- 캐시 데이터는 언제 만료되는가? → 만료 정책을 만들어야 하고, 너무 짧지도, 길지도 않게 해야한다.
- 일관성은 어떻게 유지되는가? → 단일 트랜잭션이 아닌경우 일관성이 깨질 수 있다.
- 장애 대처는 어떻게 하나? → 캐시 서버를 한 대만 두면 SPOF가 될 수 있어 분산시켜야 한다.
- 캐시 크기는 어떻게 정하나? → 메모리가 너무 작으면 캐시 성능이 떨어지게 된다.
- 데이터 방출은 무엇인가? → 캐시가 꽉 차면 기존 데이터를 내보낸다. (LRU, LFU, FIFO등)

# CDN(콘텐츠 전송 네트워크)

정적 콘텐츠를 전송하는데 쓰이는, 지리적으로 분산된 서버 네트워크. (Image, Video, CSS, JavaScript등)

동적 콘텐츠 캐싱은 요청 경로, 쿼리스트링, 쿠키, 요청 헤더 등 정보에 기반하여 HTML을 캐시하는 것이다.

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/424e306d-95c6-41ec-8616-28b1a22b21ed)

**CDN의 동작 방법**

1. 사용자가 웹사이트를 방문한다.
2. 가장 가까운 CDN 서버가 정적 콘텐츠를 전달한다.
3. 가까운 CDN에 정적 콘텐츠가 없으면, CDN에서 원본서버로 콘텐츠 요청한다.
4. 사용자는 CDN에서 해당 정적 콘텐츠를 제공받는다.
5. TTL이 끝나면 정적 콘텐츠는 사라진다.

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/7f8bfdff-e4a7-4dfc-b70a-d065bd5f107a)

**고려사항**

- CDN은 서드파티 사업자에 의해 운영되며 사용양에 따라 금액을 내기에 자주 사용되는 콘텐츠만 저장한다.
- 시간에 민감한 데이터는 만료 시점을 잘 정해야 한다.
- CDN 장애 발생을 예상하고 대처법을 만들어야 한다.
- 만료되지 않은 콘텐츠더라도 무효화할 방법이 있다.

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/24dce3f1-e101-47d1-a673-d0b7b3a829bd)

캐시와 CDN을 추가하면 이렇게 설계할 수 있다.

# 무상태 웹 계층

웹 계층을 수평적으로 확장하기 위해선, 상태성을 없에야 한다. 가장 좋은 방법은 상태를 DB에 저장하는 것.

### 상태 의존 아키텍처

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/db699a2f-e91d-432e-bcfe-c3473f3b1131)

이렇게 되면 각 사용자는 본인의 세션 데이터가 있는 서버로 요청을 보내야 한다.

대부분의 로드밸런서가 이를 지원하기 위해 고정 세션이라는 기능을 제공한다. (부하가 늘고, 관리 포인트가 늘어 좋은 방법은 아니다)

### 무상태 아키텍처

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/84d4eb5e-e095-445c-b74f-eeef3e5b1989)

이는 매우 안정적이며 확장이 쉽다.

# 데이터 센터

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/6a4ecb4b-06ea-4dfc-975d-f6d15cd32786)

두 개의 데이터 센터를 이용하는 사례다.

지리적 라우팅 : 장애가 없는 상황에서 사용자는 가장 가까운 데이터 센터로 안내된다.

데이터 센터중 하나가 심각한 장애가 발생하면 다른 데이터 센터가 트래픽을 감당한다.

규모의 확장을 위해서 시스템 컴포넌트를 분리하여 독립적인 수행이 가능하도록 해야한다.

**필요한 기술**

- 트래픽 우회 : 올바른 데이터 센터로 트래픽을 보내는 방법 (GeoDNS)
- 데이터 동기화 : 데이터 센터마다 별도의 DB를 사용하면 동기화가 필요하다.
- 테스트와 배포 : 여러 데이터 센터를 사용하도록 시스템이 구성된 상황이라면 테스트가 중요하다.

# 메시지 큐

메시지 큐는 메시지의 무손실을 보장하는 비동기 통신 컴포넌트이다.

메시지의 버퍼 역할을 하며, 비동기적으로 전송한다. 메시지 큐의 기본 아키텍처는 간단하다. 발행자가 메시지를 말들고, 구독자가 메시지를 받아 이에 맞는 동작을 수행한다.

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/2695e483-b9ab-49ae-a5c7-102d9142428c)

메시지 큐는 서버 간 느슨한 결합이 가능해서, 규모 확장성 보장에 좋다.

생산자와 소비자의 연결 상태와 관계 없이 각자의 동작을 할 수 있다.

# 로그, 메트릭 그리고 자동화

웹 사이트의 규모가 커질수록 로그와 메트릭같은 도구는 필수로 있어야 한다.

- 로그 : 에러 모니터링과 문제 파악에 도움을 준다. 로그를 단일 서비스로 모아주는 도구를 활용하면 더 편리하다.
- 메트릭 : 메트릭을 잘 수집하면 사업 현황에 관한 유용한 정보와 시스템의 상태를 손쉽게 파악할 수 있다.
    - 호스트 단위 메트릭 : CPU, 메모리, 디스크 I/O
    - 종합 메트릭 : DB 성능, 캐시 성능
    - 핵심 비즈니스 메트릭 : 일병 능동 사용자, 수익, 재방문 등
- 자동화 : 시스템이 크고 복잡해지면 생산성을 위해 자동화 도구를 활용해야 한다. CICD, 빌드, 테스트, 배포 등

### 메시지 큐, 로그, 메트릭, 자동화 등을 반영한 설계안

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/af934387-2af1-4046-854b-8f745646d423)

메시지 큐 덕분에 각 컴포넌트가 느슨한 결합이 되었다.

로그, 메트릭, 모니터링, 자동화 도구를 추가했다.

# 데이터베이스 규모 확장

### 수직적 확장

기존 서버의 자원을 더 좋은 자원으로 교체하는 것이다.

이는 극명한 한계가 있으며, 높은 비용과 SPOF의 위험이 있다.

### 수직적 확장

샤딩이라고도 하는데, 더 많은 서버를 추가해 성능을 향상시킨다.

- 샤딩 : DB를 샤드라는 작은 단위로 분할하는 기술이다.
    - 모든 샤드는 같은 스키마를 사용하지만, 데이터 중복은 없다.
- 샤딩 키 : 데이터를 어떻게 분산할지 정하는 하나 이상의 컬럼이다. 고르게 분산 하는게 포인트
    - 재 샤딩 : 샤드에 데이터가 너무 많을 때, 샤드간 데이터가 불균형적일 때
- 유명인사 문제 : 특정 샤드에 쿼리가 집중되어 서버 과부하가 생기는 경우.
- 조인과 비정규화 : 각 샤드의 데이터는 조인하기 힘들다. 그래서 이를 비정규화로 풀어내기도 한다.

# 백만 사용자, 그 이상

시스템 규모 확장은 지속적이고 반복적인 과정이다.

사용자에 맞게 새로운 전략을 사용하고, 지속적인 리팩토링이 필요하다. 예를들어 시스템 분할 등

**정리**

- 웹 계층은 **무상태**
- 모든 계층 **다중화**
- 캐시는 다다익선
- 여러 데이터 센터를 지원할 것
- 정적 콘텐츠는 CDN에
- 데이터 계층은 샤딩을 통해 분리
- 각 계층은 독립적인 컴포넌트로 만들 것
- 시스템을 지속적으로 모니터링 및 자동화 도구 사용할 것
