# 12장 채팅 시스템 설계

# 1단계 문제 이해 및 설계 범위 확정

초반에 던져야 하는 질문

- 1:1 채팅 앱인지, 그룹 채팅 앱인지
- 모바일 앱인지, 웹 앱인지
- 처리해야하는 트래픽 규모
- 그룹 채팅 규모
- 주요기능
- 메시지 길이 제한
- 종단 간 암호화
- 채팅 이력 보관 기간

# 2단계 개략적 설계안 제시 및 동의 구하기

클라이언트는 서로 직접 통신하지 않는다. 서버를 통해 통신한다.

채팅 서비스가 제공해야 하는 기능

- 클라이언트로부터 메시지 수진
- 메시지 수진자 결정 및 전달
- 수신자 접속 상태가 아닌 경우에는 접속할 때까지 해당 메시지 보관

**통신 프로토콜**

대부분이 HTTP와 keep-alive 헤더를 사용해왔다. 하지만 메시지 수신 시나리오는 이것보다 복잡하다. 이 동작을 위해 폴링, 롱 폴링, 웹소켓 등 기술이 생겼다.

### 폴링

주기적으로 서버에게 세 메시지가 있는지 질의한다.

이는 서버 자원이 불필요하게 낭비되는 문제가 있다.

### 롱 폴링

폴링의 비효율적인 방법을 개선한 방법이다.

클라이언트는 새 메시지가 반환되거나 타임아웃 될 때까지 연결을 유지한다.

이 방법은 세가지 단점이 있다.

- 메시지 보내는 클라이언트와 메시지를 수신하는 클라이언트가 다른 서버에 접속할 수 있다.
- 서버 입장에서 클라이언트와의 연결상태를 알 수 없다.
- 여전히 서버 자원이 불필요하게 낭비된다.

### 웹소켓

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/384d1d30-913d-4fdf-ac84-eb89ef08d501)

클라이언트가 연결을 수립하면 양방향 통신을 시작한다. (HTTP 연결 → 웹소켓 연결)

웹소켓 연결로 업그레이드되면 비동기로 메시지 전송이 가능하다.

메시지를 보내고, 받을 때 같은 프로토콜을 사용하기에 설계와 구현이 단순하고 직관적이다.

단, 연결이 항구적으로 유지되어야 하기 때문에 서버에서 연결 관리를 효율적으로 해야한다.

### 개략적 설계안

**무상태 서비스**

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/ac0a0131-03e3-46a3-901c-3c7baa7d1c8a)

무상태 서비스는 로드밸런서가 하는 요청을 그 경로에 맞는 서비스로 전달한다.

**상태 유지 서비스**

유일하게 상태를 유지해야하는 서비스는 채팅 서비스 뿐이다.

각 클라이언트가 채팅 서버와 독립적인 네트워크 연결을 유지해야 하기 때문이다.

**서드파티 서비스 연동**

가장 중요한건 푸시 알림이다.

앱이 실행중이지 않더라도, 알림을 받아야 하니 푸시 알림 서비스와 통합이 필요하다.

**규모 확장성**

트래픽 규모가 얼마 되지 않을 때는 모놀리틱 서비스로 운영이 가능하다.

대량의 트래픽을 처리할 때, SPOF 방지를 위해 등 분산 환경을 만드려면 이렇게 해보자.

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/f6176dd7-29f6-4bae-b7da-e453f9a57a37)

- 채팅 서버는 클라이언트 사이에서 메시지를 중계한다.
- 접속상태 서버는 사용자의 접속 여부를 관리한다.
- API 서버는 로그인, 회원가입, 프로파일 변경 등 나머지를 처리한다.
- 알림 서버는 푸시 알림을 보낸다.
- 키-값 저장소는 채팅 이력을 보관한다.

**저장소**

어떤 데이터 베이스를 써야할까?

채팅 시스템의 데이터는 두가지이다.

- 사용자 프로필, 설정, 친구목록과 같은 일반적인 데이터는 RDBMS에 저장한다.
- 채팅 이력은 읽기/쓰기 연산 패턴을 이해해야 한다. (보통 key-value 저장소를 사용한다)
    - 채팅 이력 데이터의 양은 엄청나다.
    - 빈번하게 사용되는 것은 주로 최근에 주고 받은 메시지다.
    - 대체로 최근 데이터를 보지만, 검색이나 언급을 보기위해 무작위 데이터 접근을 하기도 한다.
    - 1:1 채팅의 경우 읽기, 쓰기 비율이 거의 1:1이다.

key-value 저장소를 선택한 이유는 다음과 같다.

- 수평적 규모 확장이 쉽다.
- 데이터 접근 laytency가 낮다.
- rdbms는 long tail을 잘 처리하지 못하는 경향이 있다.

### 데이터 모델

**1:1 채팅을 위한 메시지 테이블**

pk는 message_id로 사용하며 created_at을 사용하여 메시지 생성시각을 저장한다.

**그룹 채팅을 위한 메시지 테이블**

기본키는 channel_id, message_id를 사용한 복합키 이며, 여기서 channel_id는 파티션 키로도 사용한다.

**메시지 ID**

- message_id는 고유해야 한다.
- ID 값은 정렬 가능해야 하며 시간 순서와 일치해야 한다. 즉 새로운 ID는 이전 ID보다 큰 값이어야 한다.
- nosql은 auto_increment를 지원하지 않기 때문에 64bit 순서 번호 생성기를 이용하면 된다.

# 3단계 상세 설계

### 서비스 탐색

적합한 채팅 서버의 기준

- 클라이언트 위치
- 서버의 용량

서비스 탐색 기능은 보통 아파치 주키퍼를 사용한다.

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/ae138420-86db-4b7f-a743-f6272138af6d)

1. 사용자 A가 시스템에 로그인 한다.
2. 로드밸런서가 로그인 요청을 API 서버 가운데 하나로 보낸다.
3. API 서버가 사용자 인층을 처리한 뒤 서비스 탐색 기능으로 최적의 채팅 서버로 보낸다.
4. 사용자는 채팅 서버2와 웹소켓 연결을 맺는다.

### 메시지 흐름

1:1 채팅과, 여러 단말 간 메시지 동기화 과정을 살펴보자.

**1:1 채팅 메시지 처리 흐름**

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/6c425891-2fcb-4b83-a939-9cf33be687da)

1. 사용자 A가 채팅 서버 1로 메시지 전송
2. 채팅 서버 1은 ID 생성기로 해당 메시지의 ID 결정
3. 채팅 서버 1은 해당 메시지를 메시지 동기화 큐로 전송
4. 메시지를 key-value 저장소에 보관
5. 사용자 B가 접속중인 경우 B가 접속중인 채팅 서버로 전송, 아니라면 푸시 알림 서버로 전송
6. 채팅 서버 2는 메시지를 사용자 B에게 웹소켓으로 전송

**여러 단말 사이의 메시지 동기화**

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/68bd0610-e261-45b8-86f5-9afe0131c288)

사용자 조건

- 사용자 A는 휴대폰과 랩탑 두 대의 단말을 이용한다.
- 두 단말은 모두 채팅 서버 1에 연결되어 있다.
- 각 단말은 cur_max_message_id라는 변수를 유지한다. 이는 관측된 가장 최신의 메시지의 ID를 추적하는 용도이다. 아래 두 조건을 만족하면 메시지는 새 메시지로 간주한다.
    - 수신자 ID가 현재 로그인한 사용자 ID와 같다.
    - key-value 저장소에 저장된 메시지로서 그 ID가 cur_max_message_id보다 크다.

즉, 각 단말에서 수신한 메시지 id로 최신화 한다.

**소규모 그룹 채팅에서 메시지 흐름**

1:1 채팅에 비해 그룹 채팅에서의 메시지 흐름은 조금 더 복잡하다.

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/7876d702-f514-47ea-856e-33c76eefe723)


사용자 A,B,C가 같은 채팅방에 있을 때 A가 보낸 메시지는 동기화 큐에 복사되어 각 사용자에게 간다.

- 메시지 동기화 플로우가 단순하다.
- 그룹이 크지 않으면 메시지를 수신자 별로 복사해서 큐에 넣는 작업의 비용이 문제가 되지 않는다.
- 일반적으로 이 방법은 그룹에 사용자가 많아지면 적합하지 않다. (위챗은 500명 제한)

### 접속상태 표시

개략적 설계안에서는 접속상태 서버를 통해 사용자의 상태를 관리한다고 했었다.

**사용자 로그인**

클라이언트가 실시간 서비스 사이의 웹소켓 연결이 맺어지게 되면, 서버는 사용자의 상태와 last_active_at 타임스탬프를 key-value 저장소에 보관한다.

이 작업 이후로는 해당 사용자는 접속 중인 것으로 표시된다.

**로그아웃**

key-value 저장소에 보관된 사용자의 상태를 변경한다.

**접속 장애**

사용자의 인터넷 연결이 끊어지면 웹소켓도 끊어진다.

간단한 방법은 사용자를 오프라인 상태로 표시하고, 연결이 복구되면 온라인으로 변경하는 것이다.

하지만, 이 방법은 잠시 터널을 지나가는등 짧은 연결 실패에는 바람직하지 않다.

이는 heartbeat 검사를 통해 문제를 해결한다. 즉 온라인 상태를 클라이언트로 하여금 주기적으로 heartbeat event를 접속상태로 서버로 보내게 하고, 마지막 이벤트를 받은지 N초 이내에 또다른 이벤트를 받으면 접속상태로 인식한다.

ex)5초마다 heartbeat event를 보내고, 30초동안 이벤트를 받지 못하면 오프라인 상태로 변경

**상태 정보의 전송**

![image](https://github.com/4k-study/book-System-Design-Interview/assets/85796588/37342f67-921e-44d1-b000-bff3eaf1f696)


pub-sub 구조를 사용해 친구관계 마다 채널을 하나씩 둔다.

이 방법은 그룹 크기가 커지면 사용할 수 없다. 친구 목록을 수동 업데이트 하거나, 접속시 확인하는 방법도 생각해보자.

# 4단계 마무리

실시간 통신은 웹소켓으로, 메시징은 채팅, 접속 상태, 푸시 알림, 이력 보관 서버로 나누었다.

추가 논의 할 내용

- 채팅 앱이 비디오나, 사진같은 미디어 파일 지원 유무 (썸네일)
- 메시지 종단간 암호화
- 캐시
- 로딩 속도 개선 - 슬랙은 지역 분산을 통해 로딩 속도를 개선했다.
- 오류 처리 (채팅 서버 오류, 메시지 재전송)
